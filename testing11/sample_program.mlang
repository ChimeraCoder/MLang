
;;'Twinkle Twinkle Little Star' is a song with five 'phrases' in all, but only three of them are distinct (after playing all three, the third is repeated, then the first two are played)
(define first-phrase %(A 500) %(A 500) %(E 500) %(E 500) %(F# 500) %(F# 500) %(E 500))
(define second-phrase %(D 500) %(D 500) %(C# 500) %(C# 500) %(B 500) %(B 500) %(A 500))
(define third-phrase %(E 500) %(E 500) %(D 500) %(D 500) %(C# 500) %(C# 500) %(B 500))

;;This kind of format may be common, so let's define a function to create it and give it a name. 
;;I'm not feeling very creative, so let's call it mozart-form, in accordance with Stigler's Law of Misnomy, after the
;;man who most certainly did not compose the song.

(define mozart-form
  (lambda (x)
    (lambda (y)
      (lambda (z)
        (join-phrases x y z z x y))))) ;;Join-phrases simply concatenates the musical phrases specified

(define twinkle-twinkle-little-star (mozart-form first-phrase second-phrase third-phrase third-phrase first-phrase second-phrase))

;;Now, twinkle-twinkle-little-star is a function that requires no input, so it has a single, fixed value
;;We can compile such functions at the OS shell (not the Mlang REPL) as follows:
;;$> mlang -c file_name.mlang twinkle-twinkle-little-star my_song.midi && vlc my_song.midi
;;(This assumes that an audio player with a  MIDI synthesizer is already installed on the machine, which is system-dependent and beyond
;;the scope of the MLang language. 'vlc' can be replaced with any appropriate audio player that provides a MIDI synthesizer.


;;"Row Row Row Your Boat" is an example of a rondo - a piece which contains multiple voices which enter/exit at staggered intervals.
;;Most rondos have four or more voices, but we can define a two-voice rondo as follows

(define two-voice-rondo
  (lambda (x)
    (lambda (y)
        (parallel-join                      ;;This function joins two phrases in such a way that the MIDI representation will play the phrases simultaneously
         x
         (join-phrases %(0 y) x)            ;;Frequency 0 is the notation for a rest, since it makes no sense as a musical note.
                                            ;;The above line will play a rest for the specified amount of time (2nd arg) before playing the specified phrase (1st arg)
         ))))

;;The above function will create a two-voice/two-instrument rondo from a specified piece, with a specified offset
;;The offset simply specifies when the second voice should enter. "Row Row Row Your Boat" is a four-phrase rondo, so the second voice would probably enter right when the first voice finishes the first phrase.

;;Now, we could define the four phrases for "Row Row Row Your Boat", but instead, I'm curious what "Twinkle Twinkle Little Star" would sound like as a two-voice rondo.
;;Aren't you?

(define twinkle-rondo (two-voice-rondo twinkle-twinkle-little-star (duration first-phrase))) 
;;The offset is equal to the length/duration of the first phrase of the piece, which is conveniently stored first-phrase, so we can pass it to the 'duration' function.

;;However, this is a little awkward, because first-phrase is contained within twinkle-twinkle-little-star. Having to define it separately just so we know when to offset the second voice is a little ugly, and anti-modular.
;;Fortunately, because of the way that musical notes, phrases, and functions are represented internally, we can do the following: 

(define twinkle-rondo-better
  (two-voice-rondo
    twinkle-twinkle-little-star
    (duration (car twinkle-twinkle-little-star))))

;;Here, the 'car' function simply takes the first phrase from the 
;;The function name is stolen (with pride) from Lisp.

;;You may notice that twinkle-twinkle-little-star is specified twice in this function call, which suggests that further refactoring can - and should - be done.
;;This makes sense from a musical perspective, since two-voice rondos will almost always have the second voice begin the first phrase as soon as the first voice finishes the first phrase.
;;This suggests that we could rewrite two-voice-rondo as a function two-voice-rondo-better which takes only a single argument, not two.
;;This not difficult, so it is left as an exercise for the reader as practice in writing MLang functions.


;;Note:
;;Veteran Lispers may realize now that playing a fully-specified song (a function that requires no additional arguments) is tantamount to playing all of the notes specified within a list, where the elements may be either lists or single notes
;;In other words, playing a fully-specified song is simply an inorder traversal of the tree generated by the function that creates the song. Since a function is just a list, and a note is just a list, and since every function implies a tree of functions-or-notes, MLang is homoiconic by virtue of the fact that one may compose a song by *directly-or-indirectly* modifying the internal representation of the program, not just indirectly (as would be the case in a heteroiconic language).[1]


;;Now, we can create a MIDI file of twinkle-rondo-better, just as we did for twinkle-twinkle-little-star. However, this is essentially the same as compiling a C program that has its input hard-coded into it.
;;Programs that take no input are rather boring, so let's use this opportunity to show another way to create the same MIDI file.


;;$> mlang -c file_name.mlang two-voice-rondo-better --input "(join-phrases twinkle-twinkle-little-star)"  --output my_song.midi

;;First, it should be noted that join-phrases, when called with a single phrase, will simply create a list of length 1 containing that phrase.
;;Note what's happening above. The function two-voice-rondo is being called, with the contents of the string specified as the input to the function. In other words, the contents of the string specified by --input are being evaluated as an MLang expression, and the result is passed as the input to two-voice-rondo. Then, after the interpreter has evaluated two-voice-rondo with this input, the result is being compiled and fed to a MIDI generator, with the result stored in my_song.midi.


;;Notice that we could have done something very interesting:


;;$> echo "(join-phrases twinkle-twinkle-little-star)" > two_voice_rondo_input.mlang
;;$> mlang -c file_name.mlang two-voice-rondo --input-file two_voice_rondo_input.mlang --output my_song.midi

;;Here, we have stored the input in a separate file, so it does not have to be specified ni full at the command-line.
;;However, notice the extension on the input file - the input file _is itself an MLang program_. Since arguments to a function are stored as a list, the input arguments are just a list as well.

;;MLang programs accept other MLang programs as input.
;;This is not simply a nifty feature of interest for novelty value. It is designed to be *the* core feature of MLang.


;;MLang differs from many languages in that the compiler cannot create executables that accept input, since the input must be evaluated, which would require bundling an entire MLang interpeter with the compiled output.
;;However, most interpreted scripting languages (like Python) _only_ allow programs to be interpreted, so offering static compilation of certain programs should be viewed as an additional benefit over scripting languages, not as a drawback compared to purely compiled languages.
;;Also, unlike many Lisps, the compiled executables are cross-platform, so a tradeoff has been made.

;;[1]Warning: For Lisp purists/pedants only: 
;;Veteran Lispers may notice that, but Lisp _purists_ may be squirming in their seats at the fact that notes are lists, not atoms -- and thus where does the inorder traversal terminate? Such purists may breathe more easily once they think of notes as cons cells which contain two elements, both of which are lambda functions that take zero inputs and evaluate to either a single number, which is interpreted as either a single frequency (ie, A -> 440 hz) or a duration (500 -> 500 ms), depending on whether it is the first or second element in the cons cell. Thus, the inorder traversal terminates once it reaches a cons cell with a second element that is a lambda function (all other cons cells contain either 'NIL or another cons cell as their second element, because all other cons cells are simply building blocks of lists, as in all Lisp-like languages).
;;This may be of great comfort to Lisp purists, but at the loss of everyone else, who is probably wishing that they had never read this footnote.
