1 Introduction
This manual serves to provide an in-depth description of the Turing Complete programming language MLang. It assumes a considerable familiarity in the syntax of MLang. For a tutorial introduction to MLang, see the MLang Tutorial(make to italics).

1.1 MLang History
MLang was developed in 2012 at Columbia University, New York. The motive behind the project was to create a Turing Complete programming language that could be used to create music in a grammatically accurate manner. 

MLang may or may not be a Lisp, as there is no unifying specification that defines a Lisp dialect, as compared to a language that is merely Lisp-like. MLang shares many common properties with the two most popular Lisp implementations: Common Lisp and Scheme. Like both languages, MLang is a functional language. Like both languages, MLang supports higher-order functions. Like both languages, MLang uses S-expressions for its syntax. Like Scheme, MLang uses the same namespace for variables and functions (such languages are known as Lisp-1 dialects, as opposed to Lisp-2 dialects). Like Common Lisp and Scheme, MLang is homoiconic. Unlike other Lisp dialects, however, the homoiconicity uses the concept of a \emph{note} (as in musical note) as the internal equivalence point for functions. MLang's interpreter is written in Ocaml.

1.2 Conventions
This details how the code is constructed in MLang.

1.2.1 Terms
Throughout the manual, references to "MLang Reader" and "MLang Printer" refer to the processes that convert the text in the program to MLang objects for evaluation and vice versa. Any use of the term "you", refer to the programmer or the person reading the manual as appropriate. 

MLang functions are written as -

{format}
open-paren name-of-play duration close-paren

Eg:

(rondo rondo-components) calls the function 'rondo' that plays, as a rondo, the individual components specified by rondo-components (the sole parameter).

1.3 Acknowledgements

2 MLang Data Types
In MLang the primitive data type is the MNote, which is treated entirely equivalently to a function. In fact, an MNote is simply a function that takes in zero parameters and has a single fixed output. (Because MLang is homoiconic, notes may also be used where functions are expected, and this is perfectly valid syntax; this practice has semantic meaning when metaprogramming in MLang, which is discussed later).

A single note in MLang can be written as -

%name-of-note {format}

Here '%' is a note identifier rather than a shell prompt. An example of a note can thus be given as-

%A {format}

This represents the musical note 'A' with a play time of 50ms. 

Similar to the single-quote in Common Lisp, % is simply syntactic sugar for (make-note \emph{args})

(Veteran Lispers may be interested to note that, unlike most Lisp dialects, MLang does not have literal atomic values - the above representation of a note is simply syntactic sugar for the equivalent lambda function composition. Even when metaprogramming higher-order functions, the user never specifies literal notes. Instead, the user specifies functions that always evaluate to a single, fixed value, which is the desired note. This feature of MLang allows MLang to be more homoiconic than Lisp dialects with atomic literals, which allows for metaprogramming in ways that many Lisp dialects do not allow without macros)

2.1 Printed Representation
The printed representation is the format of the output generated by the MLang execution. Every data type has a unique printed representation. The read syntax of an object is the format accepted by the MLang program for that object. When you evaluate an expression interactively, the MLang reader reads the text, produces and object and evaluates that object.

2.2 Comments
A comment is a text that is written purely to establish clarity in the program when read by the programmer or others. The text enclosed by the comments are not evaluated by the MLang interpreter. In MLang, the comments are marked by a semicolon, ';'. 
When a text starts with the comment symbol, the entire string is not read. 
Eg:

;this is a comment
(play (treble 5)) 

For commenting out functions, the ';' symbol must be used at the beginning of every like of the function.
Eg:

 ; this function has been commented
 ; (play (canon 500) 
 ;  	 	(rondo 100))


Ommiting any of the three semicolons above would result in a syntax error.

3 MLang Functions
In MLang, functions are defined by a set of enclosing parenthesis. The function is can be considered to be defined like a lambda, which is eventually evaluated to a series of notes. During evaluation, a function is treated just like a note (or a series of notes) but with arguments.

3.1 Variable Scope
Like Common Lisp and Scheme (and unlike EmacsLisp), Mlang is primarilly lexically scoped by default. $label$ may be used to create lexical bindings, while $define$ creates dynamically scoped variables. For example:

>(define *key* D)
*KEY*

>(defun check-key() *key*)
CHECK-KEY

>(check-key)

>(defun mystery-key (change-key)
  (if change-key
    (let ((*key* B)) (check-key))
    (check-key)))

>(mystery-key FALSE)
D

>(mystery-key TRUE)
B

>*key*
D

This same process can be used to modify other characteristics of a musical passage, such as the tempo, without any change to the passage itself.


4 Modules
MLang modules are simply functions that may be defined, exported, and imported freely. Since MLang is homoiconic, any valid S-expression can be imported or exported as a module and substituted for either a function or a note, as if it were defined natively within the program. The MLang composer's ability to define, import, and export arbitrary functions, combined with the powerful scoping, means that MLang allows arbirary modularity in its musical compositions. A composition can be written as a template - complete except for a single missing component, which is to be provided as the argument to a function. \emph{Any} MLang expression can be provided as the argument to the function; as long as the function application evaluates to a semantically meaningful value, the result is an entire, complete composition. 

Nearly all MLang modules are implemented in pure MLang as compositions of other MLang functions, of lambda functions (which are implemented in OCaml), or a combination of both. For functions defined in pure MLang, there is no distinction between the standard library functions and those defined by the user; the former are simply functions that are automatically defined when the program is loaded and provided dynamic scope. Because of the MLang scoping rules, it is possible to redefine these functions, and the new definitions will apply to all applications of the function within the same dynamic scoping environment. (Yes, this means that you can redefine TRUE to FALSE and FALSE to TRUE, as long as you do it in the topmost function call provided. MLang is non-judgemental when it comes to your experimental performance art).

The following functions are defined in pure MLang and available for use in the standard library.

4.1 Duration

Evaluates to the duration (in milliseconds) of the musical passage represented by its parameter

(duration yankee-doodle-dandy)
10000


4.2 Trill
A musical trill is a rapid sucession of alternating, adjacent notes (such as B and C). The trill function will turn each individual note in the musical segment provided into a trilled version of the note. The duration of the trilled version will be the same as the duration of the original.

Example:

(trill C)

(trill first-measure) ;;Will trill all notes specified by first-measure, where first-measure is a variable defined in this environment

5 Lists
Similar to Lisp, MLang processes all values as lists. The primitive data type MNote can be considered as a list of size 1. Functions are a series of MNotes. If the cdr of a list contains a value, then the list is evaluated as a function, and if the cdr is empty, then the list is considered to be a single note. 

(Note: New Lispers may be wondering how all values are lists, if all values are notes. The truth is that there's not much of a difference. A note is uniquely specified by two values - its pitch/frequency and duration. Thus, a note can be represented as a two-element list. In Lisp, lists are actually chains of two-element cells known as cons cells, where the elements of a cell may be of any type (including other cells). Thus, everything that is a list in Lisp is really a chain of cons cells. In MLang, cons cells are really notes, where the two elements may be used as pitch and frequency, or they may be used to build linked lists in the way that cons cells are used in Lisp.)

6 Evaluation of an MLang Expression

When a function written in MLang is called, the value of the function is computed by evaluating the expressions written in the function body. Evaluation of an expression written in MLang is done in a recursive manner i.e. it involves evaluating expressions within an expression, starting right from a single argument.  


“##We can talk about environment here. I was not sure how it happens”
^ Here we have a design decision: do we want eager or lazy evaluation? (This is analogous to normal order vs. applicative order in lambda calculus). Common Lisp uses eager evaluation, (though it's possible to force it to use lazy evaluation instead - the question is what we want to provide as the default/standard behavior, since we have to pick one and be consistent).

We can have Self-evaluating functions that evaluate to the object being evaluated, and Symbol forms that refer to a symbol table to return a variable’s value. Function and Module forms are evaluated by computing the value of the expressions/ nested expressions in the function.

7 Compiling and Running an Mlang Program

An Mlang program is simply a series of function calls that are evaluated by performing \beta-reductions on the appropriate lambda functions, The result is a lambda expression in normal form, represented as an S-expression. (Note that no lambda expression may have two distinct normal forms, and two expressions that share the same normal form define the same musical composition). If the result is a complete composition (ie, the normal form uniquely defines a series of notes and requires no addtional parameters for function application), this can be translated into a MIDI stream. Otherwise, the result is a more compact lambda expression which can be exported as a module and provided to another program. 

If the result is a complete composition, the notes are converted to an intermediate format that is provided to Midge, a MIDI sequencer, which produces a playable MIDI file. (Yes! You can listen to the music you just wrote!)

MLang is portable in the sense that it does not depend upon the machine’s hardware for its execution. ;;Is this the case? We're dependent on the platform-independence of Midge and OCaml - there are supposedly platform-independent versions of OCaml, but I don't know if we can guarantee that we're compatible with them.




